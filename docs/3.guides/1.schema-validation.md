---
title: Schema Validation
description: DDML integration and validation patterns
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Guide
  - Schema
  - DDML
  - Validation
---

# Schema Validation

DOCQL validates queries against a DDML schema. This guide covers schema setup, validation behavior, and error handling.

## Defining a Schema

Create a DDML schema with collections and fields:

```go
import "github.com/zoobzio/ddml"

schema := ddml.NewSchema("myapp")

// Users collection
schema.AddCollection(
    ddml.NewCollection("users").
        AddField(ddml.NewField("_id", ddml.TypeString)).
        AddField(ddml.NewField("username", ddml.TypeString)).
        AddField(ddml.NewField("email", ddml.TypeString)).
        AddField(ddml.NewField("age", ddml.TypeInt)).
        AddField(ddml.NewField("active", ddml.TypeBool)).
        AddField(ddml.NewField("createdAt", ddml.TypeDate)),
)

// Posts collection
schema.AddCollection(
    ddml.NewCollection("posts").
        AddField(ddml.NewField("_id", ddml.TypeString)).
        AddField(ddml.NewField("userId", ddml.TypeString)).
        AddField(ddml.NewField("title", ddml.TypeString)).
        AddField(ddml.NewField("content", ddml.TypeString)).
        AddField(ddml.NewField("published", ddml.TypeBool)),
)
```

## Creating an Instance

Bind the schema to a DOCQL instance:

```go
instance, err := docql.NewFromDDML(schema)
if err != nil {
    return err
}
```

The instance caches collection and field lookups for fast validation.

## Validation Behavior

### Collection Validation

Collections must exist in the schema:

```go
instance.C("users")        // Valid: collection exists
instance.C("nonexistent")  // Panics: collection not found
```

### Field Validation

Fields must exist in the specified collection:

```go
instance.F("users", "email")    // Valid: exists in users collection
instance.F("users", "title")    // Panics: title not in users
instance.F("posts", "title")    // Valid: exists in posts collection
```

### Parameter Validation

Parameters must be valid identifiers:

```go
instance.P("user_id")      // Valid
instance.P("email123")     // Valid
instance.P("invalid-name") // Panics: contains hyphen
instance.P("1starts")      // Panics: starts with number
```

## Panic vs Error

By default, validation failures panic. This catches errors early during development:

```go
// These panic on invalid input
collection := instance.C("users")
field := instance.F("users", "email")
param := instance.P("value")
```

### Try Variants

For runtime validation with user input, use `Try` variants:

```go
collection, err := instance.TryC(collectionName)
if err != nil {
    return fmt.Errorf("invalid collection: %w", err)
}

field, err := instance.TryF(collectionName, fieldName)
if err != nil {
    return fmt.Errorf("invalid field: %w", err)
}

param, err := instance.TryP(paramName)
if err != nil {
    return fmt.Errorf("invalid param: %w", err)
}
```

### When to Use Each

| Scenario | Use |
|----------|-----|
| Static field names in code | `instance.F("users", "email")` |
| User-provided field names | `instance.TryF(collection, userInput)` |
| Configuration-driven queries | `instance.TryC(config.CollectionName)` |
| Tests | Either works |

## Nested Fields

Document databases support nested documents. Define them with dot notation:

```go
schema := ddml.NewSchema("app").
    AddCollection(
        ddml.NewCollection("users").
            AddField(ddml.NewField("profile.firstName", ddml.TypeString)).
            AddField(ddml.NewField("profile.lastName", ddml.TypeString)).
            AddField(ddml.NewField("address.city", ddml.TypeString)).
            AddField(ddml.NewField("address.zip", ddml.TypeString)),
    )

instance, _ := docql.NewFromDDML(schema)

// Access nested fields
firstName := instance.F("users", "profile.firstName")
city := instance.F("users", "address.city")
```

## Schema Organization

### Single Schema Instance

Create one instance per schema and reuse it:

```go
// In a package-level variable or dependency injection
var db *docql.DOCQL

func init() {
    schema := buildSchema()
    instance, err := docql.NewFromDDML(schema)
    if err != nil {
        panic(err)
    }
    db = instance
}

func GetActiveUsers() (*docql.QueryResult, error) {
    return docql.Find(db.C("users")).
        Filter(db.Eq(db.F("users", "active"), db.P("active"))).
        Render(mongodb.New())
}
```

### Multiple Schemas

For microservices with different database schemas:

```go
var (
    usersDB     *docql.DOCQL  // User service schema
    ordersDB    *docql.DOCQL  // Order service schema
    analyticsDB *docql.DOCQL  // Analytics schema
)
```

Each instance validates against its own schema independently.

## Dynamic Queries

### Safe Dynamic Field Selection

```go
func SelectFields(instance *docql.DOCQL, collectionName string, fieldNames []string) (*docql.QueryResult, error) {
    collection, err := instance.TryC(collectionName)
    if err != nil {
        return nil, err
    }

    var fields []types.Field
    for _, name := range fieldNames {
        field, err := instance.TryF(collectionName, name)
        if err != nil {
            return nil, fmt.Errorf("invalid field %q: %w", name, err)
        }
        fields = append(fields, field)
    }

    return docql.Find(collection).Select(fields...).Render(mongodb.New())
}
```

### Dynamic Filters

```go
func BuildFilter(instance *docql.DOCQL, collection string, filters map[string]string) (docql.FilterItem, error) {
    var conditions []docql.FilterItem

    for fieldName, paramName := range filters {
        field, err := instance.TryF(collection, fieldName)
        if err != nil {
            return nil, err
        }
        param, err := instance.TryP(paramName)
        if err != nil {
            return nil, err
        }
        conditions = append(conditions, instance.Eq(field, param))
    }

    if len(conditions) == 0 {
        return nil, nil
    }
    if len(conditions) == 1 {
        return conditions[0], nil
    }
    return instance.And(conditions...), nil
}
```

## Validation Errors

### Error Types

| Error | Cause |
|-------|-------|
| `collection 'X' not found in schema` | Collection doesn't exist in DDML |
| `field 'X' not found in collection 'Y'` | Field doesn't exist in collection |
| `invalid parameter name: X` | Parameter contains invalid characters |
| `invalid identifier: X` | Identifier contains suspicious patterns |

### Handling Errors

```go
result, err := query.Render(mongodb.New())
if err != nil {
    switch {
    case strings.Contains(err.Error(), "not found in schema"):
        // Schema mismatch - likely a bug or migration issue
        log.Error("schema validation failed", "error", err)
    case strings.Contains(err.Error(), "invalid"):
        // Invalid input
        return nil, fmt.Errorf("invalid query: %w", err)
    default:
        return nil, err
    }
}
```

## Field Types

DDML supports various field types that map to document database types:

| DDML Type | Go Type | MongoDB | DynamoDB | Firestore |
|-----------|---------|---------|----------|-----------|
| `TypeString` | string | String | S | String |
| `TypeInt` | int | Int32/Int64 | N | Integer |
| `TypeFloat` | float64 | Double | N | Double |
| `TypeBool` | bool | Boolean | BOOL | Boolean |
| `TypeDate` | time.Time | Date | S (ISO) | Timestamp |
| `TypeArray` | []any | Array | L | Array |
| `TypeMap` | map | Object | M | Map |

Field types are used for documentation and potential future type checking, but are not currently enforced at query time.
