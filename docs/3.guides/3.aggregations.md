---
title: Aggregations
description: Building aggregation pipelines
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Guide
  - Aggregation
  - Pipeline
  - Analytics
---

# Aggregations

Aggregation pipelines process documents through a sequence of stages. DOCQL provides a fluent API for building pipelines that render to provider-specific syntax.

## Basic Pipeline

```go
result, err := docql.Aggregate(instance.C("orders")).
    Match(instance.Eq(instance.F("orders", "status"), instance.P("status"))).
    Group(
        docql.FieldExpr(instance.F("orders", "customerId")),
        map[string]docql.Accumulator{
            "totalAmount": docql.Sum(docql.FieldExpr(instance.F("orders", "amount"))),
            "orderCount":  docql.CountAcc(),
        },
    ).
    Sort(instance.F("orders", "totalAmount"), docql.Descending).
    Limit(10).
    Render(mongodb.New())
```

## Pipeline Stages

### Match

Filter documents early in the pipeline:

```go
query := docql.Aggregate(instance.C("orders")).
    Match(instance.Eq(instance.F("orders", "status"), instance.P("status")))
// MongoDB: [{"$match": {"status": ":status"}}]
```

Multiple match stages can be chained:

```go
query := docql.Aggregate(instance.C("orders")).
    Match(instance.Eq(instance.F("orders", "status"), instance.P("status"))).
    Match(instance.Gte(instance.F("orders", "amount"), instance.P("min_amount")))
```

### Group

Group documents and compute aggregates:

```go
accumulators := map[string]docql.Accumulator{
    "total":   docql.Sum(docql.FieldExpr(instance.F("orders", "amount"))),
    "average": docql.Avg(docql.FieldExpr(instance.F("orders", "amount"))),
    "count":   docql.CountAcc(),
}

query := docql.Aggregate(instance.C("orders")).
    Group(docql.FieldExpr(instance.F("orders", "customerId")), accumulators)
// MongoDB: [{"$group": {"_id": "$customerId", "total": {"$sum": "$amount"}, ...}}]
```

### Accumulators

Available accumulator functions:

| Function | Description | Example |
|----------|-------------|---------|
| `Sum(expr)` | Sum of values | `docql.Sum(docql.FieldExpr(field))` |
| `Avg(expr)` | Average of values | `docql.Avg(docql.FieldExpr(field))` |
| `Min(expr)` | Minimum value | `docql.Min(docql.FieldExpr(field))` |
| `Max(expr)` | Maximum value | `docql.Max(docql.FieldExpr(field))` |
| `First(expr)` | First value in group | `docql.First(docql.FieldExpr(field))` |
| `Last(expr)` | Last value in group | `docql.Last(docql.FieldExpr(field))` |
| `CountAcc()` | Count of documents | `docql.CountAcc()` |

### Sort

Sort documents in the pipeline:

```go
query := docql.Aggregate(instance.C("orders")).
    Sort(instance.F("orders", "createdAt"), docql.Descending)
// MongoDB: [{"$sort": {"createdAt": -1}}]
```

### Limit and Skip

Pagination in pipelines:

```go
query := docql.Aggregate(instance.C("orders")).
    Sort(instance.F("orders", "amount"), docql.Descending).
    Skip(20).
    Limit(10)
// MongoDB: [{"$sort": ...}, {"$skip": 20}, {"$limit": 10}]
```

### Project

Reshape documents:

```go
query := docql.Aggregate(instance.C("orders")).
    Project(
        instance.F("orders", "customerId"),
        instance.F("orders", "amount"),
        instance.F("orders", "status"),
    )
// MongoDB: [{"$project": {"customerId": 1, "amount": 1, "status": 1}}]
```

### Unwind

Deconstruct an array field:

```go
query := docql.Aggregate(instance.C("orders")).
    Unwind(instance.F("orders", "items"))
// MongoDB: [{"$unwind": "$items"}]
```

### Lookup

Join with another collection:

```go
query := docql.Aggregate(instance.C("orders")).
    Lookup(
        "customers",                         // From collection (string)
        instance.F("orders", "customerId"),  // Local field
        instance.F("customers", "_id"),      // Foreign field
        "customerDetails",                   // Output field name
    )
// MongoDB: [{"$lookup": {"from": "customers", "localField": "customerId", "foreignField": "_id", "as": "customerDetails"}}]
```

## Complex Pipelines

### Sales Report

```go
result, err := docql.Aggregate(instance.C("orders")).
    // Filter to completed orders
    Match(instance.Eq(instance.F("orders", "status"), instance.P("completed"))).
    // Group by customer
    Group(
        docql.FieldExpr(instance.F("orders", "customerId")),
        map[string]docql.Accumulator{
            "totalSpent":  docql.Sum(docql.FieldExpr(instance.F("orders", "amount"))),
            "orderCount":  docql.CountAcc(),
            "avgOrder":    docql.Avg(docql.FieldExpr(instance.F("orders", "amount"))),
            "lastOrder":   docql.Max(docql.FieldExpr(instance.F("orders", "createdAt"))),
        },
    ).
    // Sort by total spent
    Sort(instance.F("orders", "totalSpent"), docql.Descending).
    // Top 100 customers
    Limit(100).
    Render(mongodb.New())
```

### Time-Based Aggregation

```go
// Group orders by date
result, err := docql.Aggregate(instance.C("orders")).
    Match(instance.Gte(instance.F("orders", "createdAt"), instance.P("start_date"))).
    Group(
        docql.FieldExpr(instance.F("orders", "orderDate")),
        map[string]docql.Accumulator{
            "dailyTotal": docql.Sum(docql.FieldExpr(instance.F("orders", "amount"))),
            "orderCount": docql.CountAcc(),
        },
    ).
    Sort(instance.F("orders", "orderDate"), docql.Ascending).
    Render(mongodb.New())
```

## Expressions

### Field Expressions

Reference document fields:

```go
expr := docql.FieldExpr(instance.F("orders", "amount"))
// MongoDB: "$amount"
```

### Literal Expressions

Use parameter values:

```go
expr := docql.LiteralExpr(instance.P("multiplier"))
// MongoDB: ":multiplier"
```

## Provider Support

Aggregation support varies by provider:

| Feature | MongoDB | DynamoDB | Firestore | CouchDB |
|---------|---------|----------|-----------|---------|
| Match | Yes | No | No | Limited |
| Group | Yes | No | No | Limited |
| Sort | Yes | No | No | Yes |
| Limit/Skip | Yes | No | No | Yes |
| Project | Yes | No | No | Yes |
| Unwind | Yes | No | No | No |
| Lookup | Yes | No | No | No |
| Sum/Avg/Min/Max | Yes | No | No | Limited |

For providers without aggregation support, consider:
1. Using application-level aggregation
2. Pre-computing aggregates in the database
3. Using provider-specific features (DynamoDB streams, Firestore functions)

## Best Practices

### Filter Early

Place `Match` stages early to reduce documents processed:

```go
// Good: Filter first
docql.Aggregate(collection).
    Match(filter).      // Reduces dataset
    Group(...).
    Sort(...)

// Bad: Filter late
docql.Aggregate(collection).
    Group(...).         // Processes all documents
    Sort(...).
    Match(filter)       // Too late
```

### Use Indexes

Ensure fields used in `Match` and `Sort` stages are indexed.

### Limit Results

Always include a `Limit` to prevent unbounded result sets:

```go
docql.Aggregate(collection).
    Match(filter).
    Group(...).
    Limit(1000)  // Safety limit
```

### Check Provider Support

Verify your pipeline stages are supported before rendering:

```go
renderer := mongodb.New()
if !renderer.SupportsPipelineStage("$lookup") {
    // Use alternative approach
}
```
