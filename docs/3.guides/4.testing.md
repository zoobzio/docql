---
title: Testing
description: Testing patterns for docql queries
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Guide
  - Testing
  - Best Practices
---

# Testing

This guide covers testing strategies for DOCQL queries, from unit tests to integration tests with real databases.

## Test Helpers

DOCQL provides test utilities in the `testing` package:

```go
import docqltesting "github.com/zoobzio/docql/testing"

func TestQuery(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    result, err := docql.Find(instance.C("users")).
        Filter(instance.Eq(instance.F("users", "active"), instance.P("active"))).
        Render(mongodb.New())

    docqltesting.AssertNoError(t, err)
    docqltesting.AssertContainsParam(t, result, "active")
}
```

### Available Helpers

| Function | Description |
|----------|-------------|
| `TestInstance(t)` | Creates a DOCQL instance with test schema |
| `AssertNoError(t, err)` | Fails if error is not nil |
| `AssertError(t, err)` | Fails if error is nil |
| `AssertParams(t, result, expected)` | Checks required params match |
| `AssertContainsParam(t, result, param)` | Checks param is required |
| `AssertPanics(t, fn)` | Checks that function panics |
| `AssertJSON(t, result, expected)` | Compares JSON output |

## Unit Testing

### Testing Query Structure

Test that queries produce the expected structure:

```go
func TestFindActiveUsers(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    result, err := docql.Find(instance.C("users")).
        Filter(instance.Eq(instance.F("users", "active"), instance.P("active"))).
        Select(instance.F("users", "username"), instance.F("users", "email")).
        Limit(10).
        Render(mongodb.New())

    docqltesting.AssertNoError(t, err)

    // Check parameters
    docqltesting.AssertParams(t, result, []string{"active"})

    // Check JSON contains expected fields
    if !strings.Contains(result.JSON, `"active"`) {
        t.Error("Expected filter on active field")
    }
    if !strings.Contains(result.JSON, `"limit":10`) {
        t.Error("Expected limit of 10")
    }
}
```

### Testing Validation

Test that invalid inputs are rejected:

```go
func TestInvalidCollection(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    docqltesting.AssertPanics(t, func() {
        instance.C("nonexistent")
    })
}

func TestInvalidField(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    docqltesting.AssertPanics(t, func() {
        instance.F("users", "nonexistent")
    })
}

func TestInvalidParam(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    docqltesting.AssertPanics(t, func() {
        instance.P("invalid;param")
    })
}
```

### Testing Try Variants

```go
func TestTryC_InvalidCollection(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    _, err := instance.TryC("nonexistent")
    docqltesting.AssertError(t, err)
}

func TestTryF_InvalidField(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    _, err := instance.TryF("users", "nonexistent")
    docqltesting.AssertError(t, err)
}
```

### Testing Filters

```go
func TestAndFilter(t *testing.T) {
    instance := docqltesting.TestInstance(t)

    filter := instance.And(
        instance.Eq(instance.F("users", "active"), instance.P("active")),
        instance.Gt(instance.F("users", "age"), instance.P("min_age")),
    )

    result, err := docql.Find(instance.C("users")).
        Filter(filter).
        Render(mongodb.New())

    docqltesting.AssertNoError(t, err)
    docqltesting.AssertParams(t, result, []string{"active", "min_age"})

    if !strings.Contains(result.JSON, `"$and"`) {
        t.Error("Expected $and operator in output")
    }
}
```

## Table-Driven Tests

Use table-driven tests for comprehensive coverage:

```go
func TestFilterOperators(t *testing.T) {
    instance := docqltesting.TestInstance(t)
    field := instance.F("users", "age")
    param := instance.P("value")

    tests := []struct {
        name     string
        filter   docql.FilterItem
        expected string
    }{
        {"Eq", instance.Eq(field, param), `"$eq"`},
        {"Ne", instance.Ne(field, param), `"$ne"`},
        {"Gt", instance.Gt(field, param), `"$gt"`},
        {"Gte", instance.Gte(field, param), `"$gte"`},
        {"Lt", instance.Lt(field, param), `"$lt"`},
        {"Lte", instance.Lte(field, param), `"$lte"`},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := docql.Find(instance.C("users")).
                Filter(tt.filter).
                Render(mongodb.New())

            docqltesting.AssertNoError(t, err)

            if !strings.Contains(result.JSON, tt.expected) {
                t.Errorf("Expected %s in output, got: %s", tt.expected, result.JSON)
            }
        })
    }
}
```

## Integration Testing

For integration tests with real databases, use testcontainers:

```go
func TestMongoDB_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }

    ctx := context.Background()

    // Start MongoDB container
    container, err := mongodb.Run(ctx, "mongo:7")
    if err != nil {
        t.Fatal(err)
    }
    defer container.Terminate(ctx)

    // Connect
    connStr, _ := container.ConnectionString(ctx)
    client, _ := mongo.Connect(options.Client().ApplyURI(connStr))
    defer client.Disconnect(ctx)

    // Create test data
    db := client.Database("test")
    collection := db.Collection("users")
    collection.InsertMany(ctx, []interface{}{
        bson.M{"username": "alice", "active": true},
        bson.M{"username": "bob", "active": false},
    })

    // Build and execute query
    instance := createTestInstance(t)
    result, err := docql.Find(instance.C("users")).
        Filter(instance.Eq(instance.F("users", "active"), instance.P("active"))).
        Render(mongodb.New())

    if err != nil {
        t.Fatal(err)
    }

    // Execute with actual values
    cursor, err := collection.Find(ctx, bson.M{"active": true})
    if err != nil {
        t.Fatal(err)
    }

    var users []bson.M
    cursor.All(ctx, &users)

    if len(users) != 1 {
        t.Errorf("Expected 1 active user, got %d", len(users))
    }
}
```

## Benchmarking

Benchmark query building and rendering:

```go
func BenchmarkSimpleFind(b *testing.B) {
    instance := createBenchmarkInstance(b)
    collection := instance.C("users")

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, err := docql.Find(collection).Render(mongodb.New())
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkComplexQuery(b *testing.B) {
    instance := createBenchmarkInstance(b)

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, err := docql.Find(instance.C("users")).
            Filter(instance.And(
                instance.Eq(instance.F("users", "active"), instance.P("active")),
                instance.Gt(instance.F("users", "age"), instance.P("min_age")),
            )).
            Select(instance.F("users", "username"), instance.F("users", "email")).
            SortDesc(instance.F("users", "createdAt")).
            Limit(10).
            Render(mongodb.New())

        if err != nil {
            b.Fatal(err)
        }
    }
}
```

Run benchmarks:

```bash
go test -bench=. -benchmem ./...
```

## Test Organization

Recommended test file structure:

```
docql/
├── builder_test.go          # Builder unit tests
├── expressions_test.go      # Filter expression tests
├── instance_test.go         # Instance/validation tests
├── testing/
│   ├── helpers.go           # Test utilities
│   ├── helpers_test.go      # Utility tests
│   ├── benchmarks/
│   │   └── render_benchmark_test.go
│   └── integration/
│       ├── setup_test.go
│       ├── mongodb_test.go
│       └── couchdb_test.go
└── pkg/
    ├── mongodb/
    │   └── mongodb_test.go  # MongoDB renderer tests
    └── ...
```

## CI Integration

Example GitHub Actions workflow:

```yaml
name: Test
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Run unit tests
        run: go test -short ./...

      - name: Run integration tests
        run: go test -v ./testing/integration/...

      - name: Run benchmarks
        run: go test -bench=. -benchmem ./testing/benchmarks/...
```
