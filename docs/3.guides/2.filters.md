---
title: Filters
description: Building complex filter conditions
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Guide
  - Filters
  - Conditions
  - Queries
---

# Filters

Filters define which documents match a query. DOCQL provides a rich set of filter operators that translate to provider-specific syntax.

## Basic Comparison

### Equality

```go
// Exact match
filter := instance.Eq(instance.F("users", "status"), instance.P("status"))
// MongoDB: {"status": {"$eq": ":status"}}
```

### Inequality

```go
filter := instance.Ne(instance.F("users", "status"), instance.P("status"))
// MongoDB: {"status": {"$ne": ":status"}}
```

### Comparison Operators

```go
// Greater than
instance.Gt(instance.F("users", "age"), instance.P("min_age"))

// Greater than or equal
instance.Gte(instance.F("users", "age"), instance.P("min_age"))

// Less than
instance.Lt(instance.F("users", "age"), instance.P("max_age"))

// Less than or equal
instance.Lte(instance.F("users", "age"), instance.P("max_age"))
```

## Set Membership

### In

Check if a field value is in a set:

```go
filter := instance.In(instance.F("users", "role"), instance.P("roles"))
// MongoDB: {"role": {"$in": ":roles"}}
// The parameter should be an array value
```

### Not In

Check if a field value is not in a set:

```go
filter := instance.Nin(instance.F("users", "status"), instance.P("excluded"))
// MongoDB: {"status": {"$nin": ":excluded"}}
```

## Existence

### Field Exists

Check if a field exists in the document:

```go
filter := docql.Exists(instance.F("users", "email"))
// MongoDB: {"email": {"$exists": true}}
```

### Field Not Exists

Check if a field does not exist:

```go
filter := docql.NotExists(instance.F("users", "deletedAt"))
// MongoDB: {"deletedAt": {"$exists": false}}
```

## Logical Operators

### AND

All conditions must be true:

```go
filter := instance.And(
    instance.Eq(instance.F("users", "active"), instance.P("active")),
    instance.Gt(instance.F("users", "age"), instance.P("min_age")),
)
// MongoDB: {"$and": [{"active": ":active"}, {"age": {"$gt": ":min_age"}}]}
```

### OR

At least one condition must be true:

```go
filter := instance.Or(
    instance.Eq(instance.F("users", "role"), instance.P("admin")),
    instance.Eq(instance.F("users", "role"), instance.P("moderator")),
)
// MongoDB: {"$or": [{"role": ":admin"}, {"role": ":moderator"}]}
```

### NOR

None of the conditions can be true:

```go
filter := instance.Nor(
    instance.Eq(instance.F("users", "status"), instance.P("banned")),
    instance.Eq(instance.F("users", "status"), instance.P("suspended")),
)
// MongoDB: {"$nor": [{"status": ":banned"}, {"status": ":suspended"}]}
```

## Nested Conditions

Combine logical operators for complex queries:

```go
// Active users who are either admins or have verified email
filter := instance.And(
    instance.Eq(instance.F("users", "active"), instance.P("active")),
    instance.Or(
        instance.Eq(instance.F("users", "role"), instance.P("admin")),
        docql.Exists(instance.F("users", "verifiedAt")),
    ),
)
```

## Range Queries

### Inclusive Range

```go
minAge := instance.P("min_age")
maxAge := instance.P("max_age")
filter := docql.Range(instance.F("users", "age"), &minAge, &maxAge)
// MongoDB: {"age": {"$gte": ":min_age", "$lte": ":max_age"}}
```

### Exclusive Range

```go
filter := docql.RangeExclusive(instance.F("users", "age"), &minAge, &maxAge)
// MongoDB: {"age": {"$gt": ":min_age", "$lt": ":max_age"}}
```

### One-Sided Range

```go
// Only minimum
filter := docql.Range(instance.F("users", "age"), &minAge, nil)
// MongoDB: {"age": {"$gte": ":min_age"}}

// Only maximum
filter := docql.Range(instance.F("users", "age"), nil, &maxAge)
// MongoDB: {"age": {"$lte": ":max_age"}}
```

## Pattern Matching

### Regex

```go
filter := docql.Regex(instance.F("users", "email"), instance.P("pattern"))
// MongoDB: {"email": {"$regex": ":pattern"}}
```

### Regex with Options

```go
filter := docql.RegexWithOptions(
    instance.F("users", "name"),
    instance.P("pattern"),
    instance.P("options"),  // e.g., "i" for case-insensitive
)
// MongoDB: {"name": {"$regex": ":pattern", "$options": ":options"}}
```

## Array Operations

### All

All specified elements must be in the array:

```go
filter := docql.All(instance.F("posts", "tags"), instance.P("required_tags"))
// MongoDB: {"tags": {"$all": ":required_tags"}}
```

### Size

Array must have exactly this many elements:

```go
filter := docql.Size(instance.F("posts", "comments"), instance.P("count"))
// MongoDB: {"comments": {"$size": ":count"}}
```

### ElemMatch

At least one array element must match all conditions:

```go
priceFilter := instance.Gte(instance.F("orders", "items.price"), instance.P("min_price"))
filter := docql.ElemMatch(instance.F("orders", "items"), priceFilter)
// MongoDB: {"items": {"$elemMatch": {"price": {"$gte": ":min_price"}}}}
```

## Text Search

Full-text search on indexed fields:

```go
filter := docql.TextSearch(instance.P("search_term"))
// MongoDB: {"$text": {"$search": ":search_term"}}
```

## Geospatial Filters

### Near

Find documents near a geographic point:

```go
filter := docql.Geo(
    instance.F("stores", "location"),
    instance.P("longitude"),
    instance.P("latitude"),
    instance.P("max_distance"),
)
// MongoDB: {"location": {"$near": {"$geometry": {...}, "$maxDistance": ":max_distance"}}}
```

## Provider Support

Not all providers support all filters:

| Filter | MongoDB | DynamoDB | Firestore | CouchDB |
|--------|---------|----------|-----------|---------|
| Eq, Ne | Yes | Yes | Yes | Yes |
| Gt, Gte, Lt, Lte | Yes | Yes | Yes | Yes |
| In, NotIn | Yes | Yes | Yes | Yes |
| Exists | Yes | Yes | No | Yes |
| Regex | Yes | Limited | No | Yes |
| And | Yes | Yes | Yes | Yes |
| Or | Yes | No | Limited | Yes |
| Nor | Yes | No | No | Yes |
| All, Size | Yes | No | Yes | No |
| ElemMatch | Yes | No | No | No |
| Text | Yes | No | No | No |
| Geo | Yes | No | Yes | Yes |

Unsupported filters return an error at render time:

```go
result, err := query.Render(dynamodb.New())
// err: "DynamoDB does not support OR conditions"
```

## Filter Patterns

### Optional Filters

Build filters conditionally:

```go
func buildQuery(instance *docql.DOCQL, filters QueryFilters) (*docql.Builder, error) {
    query := docql.Find(instance.C("users"))

    var conditions []docql.FilterItem

    if filters.Status != "" {
        conditions = append(conditions,
            instance.Eq(instance.F("users", "status"), instance.P("status")))
    }

    if filters.MinAge > 0 {
        conditions = append(conditions,
            instance.Gte(instance.F("users", "age"), instance.P("min_age")))
    }

    if len(conditions) > 0 {
        query = query.Filter(instance.And(conditions...))
    }

    return query, nil
}
```

### Reusable Filter Components

```go
// Define reusable filter builders
func activeFilter(instance *docql.DOCQL) docql.FilterItem {
    return instance.Eq(instance.F("users", "active"), instance.P("active"))
}

func adminFilter(instance *docql.DOCQL) docql.FilterItem {
    return instance.Eq(instance.F("users", "role"), instance.P("admin_role"))
}

// Combine them
filter := instance.And(
    activeFilter(instance),
    adminFilter(instance),
)
```
