---
title: Core Concepts
description: Collections, fields, params, filters, and builders - the building blocks of docql
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Concepts
  - Collections
  - Fields
  - Filters
---

# Core Concepts

DOCQL has five primitives: collections, fields, params, filters, and builders. Understanding these unlocks the full API.

## Collections

A collection represents a database collection (MongoDB), table (DynamoDB), or document path (Firestore). Create collections through a DOCQL instance:

```go
users := instance.C("users")
```

**Collections must exist in your DDML schema.** This restriction prevents injection through collection names.

```go
instance.C("users")       // Valid: collection exists
instance.C("nonexistent") // Panics: collection not found
```

## Fields

A field represents a document field. Create fields through a DOCQL instance:

```go
email := instance.F("users", "email")
username := instance.F("users", "username")
```

Fields require both the collection name and field path:

```go
// Collection-qualified field references
userEmail := instance.F("users", "email")      // users.email
orderTotal := instance.F("orders", "total")    // orders.total
```

### Nested Fields

Document databases support nested fields using dot notation:

```go
// Define nested fields in schema
schema := ddml.NewSchema("app").
    AddCollection(
        ddml.NewCollection("users").
            AddField(ddml.NewField("address.city", ddml.TypeString)).
            AddField(ddml.NewField("address.zip", ddml.TypeString)),
    )

// Access nested fields
city := instance.F("users", "address.city")
```

### Field Validation

Fields are validated against the schema. The field must exist in the specified collection:

```go
instance.F("users", "email")       // Valid if "email" exists in "users"
instance.F("users", "nonexistent") // Panics: field not found
```

## Params

A param represents a query parameter. All user values flow through params:

```go
emailParam := instance.P("email_value")
activeParam := instance.P("is_active")
```

Params are rendered as named placeholders:

```go
// In output: {"status": ":status_value"}
```

### Parameter Validation

Parameter names must be valid identifiers:

```go
instance.P("user_id")                    // Valid
instance.P("id; db.dropDatabase()")      // Panics: invalid parameter
```

## Filters

Filters represent query conditions. Create filters with helper functions:

```go
// Equality
filter := instance.Eq(instance.F("users", "status"), instance.P("status"))

// Comparison
filter := instance.Gt(instance.F("users", "age"), instance.P("min_age"))

// Existence
filter := docql.Exists(instance.F("users", "email"))
```

### Filter Operators

| Function | Operator | Description |
|----------|----------|-------------|
| `Eq` | `$eq` | Equals |
| `Ne` | `$ne` | Not equals |
| `Gt` | `$gt` | Greater than |
| `Gte` | `$gte` | Greater than or equal |
| `Lt` | `$lt` | Less than |
| `Lte` | `$lte` | Less than or equal |
| `In` | `$in` | In array |
| `NotIn` | `$nin` | Not in array |
| `Exists` | `$exists` | Field exists |
| `Regex` | `$regex` | Regex match |

See [Operators Reference](../5.reference/2.operators.md) for the complete list.

### Combining Filters

Use `And`, `Or`, and `Nor` to combine filters:

```go
// AND: both must be true
instance.And(
    instance.Eq(instance.F("users", "active"), instance.P("is_active")),
    instance.Gt(instance.F("users", "age"), instance.P("min_age")),
)
// Renders: {"$and": [{"active": ":is_active"}, {"age": {"$gt": ":min_age"}}]}

// OR: either must be true
instance.Or(
    instance.Eq(instance.F("users", "role"), instance.P("admin_role")),
    instance.Eq(instance.F("users", "role"), instance.P("mod_role")),
)
// Renders: {"$or": [{"role": ":admin_role"}, {"role": ":mod_role"}]}
```

### Nested Filters

Filters can be nested arbitrarily:

```go
instance.And(
    instance.Eq(instance.F("users", "active"), instance.P("is_active")),
    instance.Or(
        instance.Eq(instance.F("users", "role"), instance.P("admin")),
        instance.Eq(instance.F("users", "role"), instance.P("mod")),
    ),
)
// Renders: {"$and": [{"active": ":is_active"}, {"$or": [...]}]}
```

### Range Filters

Use `Range` for between-style queries:

```go
minAge := instance.P("min_age")
maxAge := instance.P("max_age")
filter := docql.Range(instance.F("users", "age"), &minAge, &maxAge)
// Renders: {"age": {"$gte": ":min_age", "$lte": ":max_age"}}
```

## Builders

Builders construct queries through method chaining. Each operation type has its own entry point:

```go
docql.Find(collection)       // Find documents
docql.FindOne(collection)    // Find single document
docql.Insert(collection)     // Insert document
docql.Update(collection)     // Update documents
docql.Delete(collection)     // Delete documents
docql.Count(collection)      // Count documents
docql.Aggregate(collection)  // Aggregation pipeline
docql.Distinct(collection, field) // Distinct values
```

### Fluent API

Methods return the builder for chaining:

```go
result, err := docql.Find(instance.C("users")).
    Filter(condition).
    Select(instance.F("users", "username"), instance.F("users", "email")).
    SortDesc(instance.F("users", "createdAt")).
    Limit(10).
    Skip(20).
    Render(mongodb.New())
```

### Build vs Render

- `Build()` returns the AST for inspection or modification
- `Render(provider)` produces the final output using the specified provider

```go
// Get the AST
ast, err := query.Build()

// Get JSON output
result, err := query.Render(mongodb.New())
```

### Must Variants

`MustBuild` and `MustRender` panic on error instead of returning it:

```go
result := query.MustRender(mongodb.New())  // Panics if invalid
```

## Try Variants

All instance methods have `Try` variants that return errors instead of panicking:

```go
// Panics on invalid input
collection := instance.C("users")
field := instance.F("users", "email")
param := instance.P("value")

// Returns error on invalid input
collection, err := instance.TryC("users")
field, err := instance.TryF("users", "email")
param, err := instance.TryP("value")
```

Use `Try` variants when handling user input or dynamic field names.

## Query Result

`Render()` returns a `QueryResult`:

```go
type QueryResult struct {
    JSON           string   // The rendered query as JSON
    RequiredParams []string // Parameter names that must be provided
}
```

The `RequiredParams` slice lists all parameters in order of appearance. Use this to validate that all required values are provided before execution.
