---
title: Architecture
description: Internal structure and design decisions
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Architecture
  - Design
  - Internals
---

# Architecture

DOCQL follows a layered architecture designed for security, extensibility, and maintainability.

## Layer Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Public API Layer                          │
│  docql.Find(), docql.Insert(), instance.C(), instance.F()...    │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Builder Layer                             │
│  Builder struct, method chaining, AST construction               │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Internal Types Layer                         │
│  DocumentAST, Collection, Field, Param, FilterItem...           │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Renderer Layer                             │
│  MongoDB, DynamoDB, Firestore, CouchDB providers                │
└─────────────────────────────────────────────────────────────────┘
```

## Internal Types

Core types live in `internal/types` and cannot be imported by external packages:

```
internal/types/
├── ast.go          # DocumentAST, Operation constants
├── collection.go   # Collection reference type
├── field.go        # Field reference type
├── param.go        # Parameter reference type
├── filter.go       # FilterItem interface, FilterCondition, FilterGroup
├── operator.go     # Filter, Logic, Update operators
├── update.go       # UpdateOperation type
├── aggregate.go    # Pipeline stages, Expression, Accumulator
├── projection.go   # Projection type
├── sort.go         # SortClause, SortOrder
└── result.go       # QueryResult type
```

### Why Internal?

Making types internal prevents external code from constructing them directly:

```go
// External package CANNOT do this:
cond := types.FilterCondition{
    Field:    types.Field{Path: "malicious'; DROP"},  // Bypasses validation!
    Operator: types.EQ,
    Value:    types.Param{Name: "x"},
}

// External packages MUST use validated accessors:
cond := instance.Eq(instance.F("users", "status"), instance.P("status"))
```

This is a key security property. The only way to create query components is through validated instance methods.

## Instance Layer

The `DOCQL` instance provides validated access to internal types:

```go
type DOCQL struct {
    schema      *ddml.Schema
    collections map[string]*ddml.Collection
    fields      map[string]map[string]*ddml.Field
}
```

### Validation Methods

Each accessor validates against the schema:

```go
func (d *DOCQL) C(name string) types.Collection {
    c, err := d.TryC(name)
    if err != nil {
        panic(err)
    }
    return c
}

func (d *DOCQL) TryC(name string) (types.Collection, error) {
    if !isValidIdentifier(name) {
        return types.Collection{}, fmt.Errorf("invalid collection name: %s", name)
    }
    if _, exists := d.collections[name]; !exists {
        return types.Collection{}, fmt.Errorf("collection %q not found in schema", name)
    }
    return types.Collection{Name: name}, nil
}
```

### Security Checks

Multiple layers of validation:

1. **Identifier validation** — Rejects special characters
2. **Schema validation** — Must exist in DDML
3. **Pattern blocking** — Rejects SQL/NoSQL injection patterns

```go
var suspiciousPatterns = []string{
    "'", "\"", ";", "--", "/*", "*/",
    "DROP", "DELETE", "UPDATE", "INSERT",
    "$where", "mapReduce", "db.",
}

func isValidIdentifier(s string) bool {
    if s == "" || strings.Contains(s, " ") {
        return false
    }
    for _, pattern := range suspiciousPatterns {
        if strings.Contains(strings.ToUpper(s), pattern) {
            return false
        }
    }
    // Must match alphanumeric + underscore pattern
    return identifierRegex.MatchString(s)
}
```

## Builder Layer

The `Builder` struct accumulates query components:

```go
type Builder struct {
    ast *types.DocumentAST
    err error
}
```

### Method Chaining

Each method returns `*Builder` for chaining:

```go
func (b *Builder) Filter(f types.FilterItem) *Builder {
    if b.err != nil {
        return b
    }
    b.ast.FilterClause = f
    return b
}

func (b *Builder) Limit(n int) *Builder {
    if b.err != nil {
        return b
    }
    b.ast.Limit = &types.PaginationValue{Static: &n}
    return b
}
```

### Error Accumulation

Errors are accumulated, not returned immediately:

```go
query := docql.Find(collection).
    Filter(badFilter).   // Error recorded
    Limit(-1).           // Not executed, error already set
    Skip(10)             // Not executed, error already set

result, err := query.Render(mongodb.New())
// err contains the first error encountered
```

## Renderer Layer

Providers implement the `Renderer` interface:

```go
type Renderer interface {
    Render(ast *types.DocumentAST) (*types.QueryResult, error)
    SupportsOperation(op types.Operation) bool
    SupportsFilter(op types.FilterOperator) bool
    SupportsUpdate(op types.UpdateOperator) bool
    SupportsPipelineStage(stage string) bool
}
```

### Provider Capabilities

Each provider declares what it supports:

| Feature | MongoDB | DynamoDB | Firestore | CouchDB |
|---------|---------|----------|-----------|---------|
| Find | Yes | Yes | Yes | Yes |
| Aggregation | Yes | No | No | Limited |
| OR filters | Yes | No | Limited | Yes |
| Geospatial | Yes | No | Yes | Yes |
| Regex | Yes | Limited | No | Yes |

Unsupported operations return clear errors:

```go
result, err := query.Render(dynamodb.New())
// err: "DynamoDB does not support aggregation pipelines"
```

## AST Structure

The `DocumentAST` captures the complete query specification:

```go
type DocumentAST struct {
    Operation     Operation
    Target        Collection
    FilterClause  FilterItem
    Projection    *Projection
    SortClauses   []SortClause
    Skip, Limit   *PaginationValue
    Documents     []Document        // For Insert
    UpdateOps     []UpdateOperation // For Update
    Pipeline      []PipelineStage   // For Aggregate
    DistinctField *Field            // For Distinct
}
```

The AST is provider-agnostic. Renderers translate it to provider-specific output.

## Package Structure

```
docql/
├── api.go           # Public type re-exports (safe types only)
├── builder.go       # Query builder
├── expressions.go   # Filter helper functions
├── instance.go      # DDML integration, validation
├── internal/types/  # Internal type definitions
└── pkg/
    ├── mongodb/     # MongoDB renderer
    ├── dynamodb/    # DynamoDB renderer
    ├── firestore/   # Firestore renderer
    └── couchdb/     # CouchDB renderer
```

## Design Principles

### 1. Defense in Depth

Multiple layers of validation ensure security even if one layer fails.

### 2. Fail Fast

Invalid inputs cause immediate panics (or errors with `Try` variants), not runtime failures.

### 3. Type Safety

Go's type system enforces correct usage at compile time where possible.

### 4. Provider Abstraction

The same builder API works across all providers; differences are handled at render time.

### 5. Minimal Re-exports

Only output types (`QueryResult`), interfaces (`FilterItem`), and enums are re-exported. Input types stay internal.
