---
title: Overview
description: Type-safe query builder for document databases
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Overview
  - Introduction
---

# Overview

Document database query builders typically trust developers to provide valid collection and field names. DOCQL takes a different approach: validate everything against a schema before rendering.

```go
import "github.com/zoobzio/docql/pkg/mongodb"

// Define your schema
schema := ddml.NewSchema("myapp").
    AddCollection(
        ddml.NewCollection("users").
            AddField(ddml.NewField("email", ddml.TypeString)).
            AddField(ddml.NewField("status", ddml.TypeString)).
            AddField(ddml.NewField("age", ddml.TypeInt)),
    )

// Create a validated instance
instance, _ := docql.NewFromDDML(schema)

// Build queries - collections and fields validated against schema
result, _ := docql.Find(instance.C("users")).
    Filter(instance.Eq(instance.F("users", "status"), instance.P("status"))).
    Select(instance.F("users", "email")).
    Limit(10).
    Render(mongodb.New())

// result.JSON: {"collection":"users","filter":{"status":":status"},...}
// result.RequiredParams: []string{"status"}
```

Type-safe, schema-validated, injection-resistant.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                         DOCQL                                │
│                                                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │    DDML     │    │   Builder   │    │   Render    │      │
│  │   Schema    │───▶│     API     │───▶│   Engine    │      │
│  │             │    │             │    │             │      │
│  │  Validates  │    │  Constructs │    │  Generates  │      │
│  │ Collections │    │  AST Nodes  │    │ JSON + Params│     │
│  │  Fields     │    │             │    │             │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                  Internal AST Types                  │    │
│  │  Collection, Field, Param, Filter, Pipeline...      │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

The DDML schema validates identifiers. The Builder API constructs an Abstract Syntax Tree. The Render engine produces provider-specific JSON output.

## Philosophy

DOCQL draws inspiration from the principle of defense in depth. Rather than trusting developers to avoid NoSQL injection, the library makes injection structurally difficult:

1. **Schema validation** — Collections and fields must exist in your DDML schema
2. **Instance-based API** — Types cannot be constructed directly
3. **Parameterized output** — Values are never interpolated into queries
4. **Internal types** — Core types are internal, preventing direct construction

```go
// Injection attempt blocked at construction
instance.C("users; db.dropDatabase()")  // Panics: collection not in schema
instance.F("users", "status'; return")  // Panics: field not in schema
instance.P("id; DELETE FROM users")     // Panics: invalid parameter name
```

The schema acts as an allowlist. If it's not in the schema, it can't be in the query.

## Capabilities

A schema-validated query builder enables:

**[Type Safety](2.learn/2.concepts.md)** — Fields, collections, and parameters are validated at construction time, not at execution time.

**[Complex Queries](3.guides/2.filters.md)** — Filters, projections, sorts, aggregation pipelines—all with the same validation guarantees.

**[Multi-Provider Support](5.reference/1.api.md)** — MongoDB, DynamoDB, Firestore, CouchDB with provider-specific rendering.

**[Composability](3.guides/3.aggregations.md)** — Build queries programmatically. Combine filters. Nest conditions.

DOCQL provides the query building layer. Execution is handled by your database driver of choice.

## Priorities

### Security

NoSQL injection is prevented through multiple layers:

| Layer | Protection |
|-------|------------|
| Schema validation | Collections/fields must exist in DDML |
| Identifier validation | Alphanumeric + underscore + dot only |
| Keyword blocking | Rejects `;`, `--`, `'`, suspicious patterns |
| Internal types | Core types cannot be constructed externally |
| Parameterized queries | Named parameters, never interpolation |

### Ergonomics

The fluent builder API reads naturally:

```go
docql.Find(collection).
    Filter(condition).
    Select(field1, field2).
    SortDesc(field1).
    Limit(10).
    Render(mongodb.New())
```

Method chaining. Compile-time errors for invalid operations. Clear separation between building and rendering.

### Multi-Provider Architecture

DOCQL supports multiple document databases through providers:

```go
import (
    "github.com/zoobzio/docql/pkg/mongodb"
    "github.com/zoobzio/docql/pkg/dynamodb"
    "github.com/zoobzio/docql/pkg/firestore"
    "github.com/zoobzio/docql/pkg/couchdb"
)

// MongoDB
result, _ := query.Render(mongodb.New())

// DynamoDB
result, _ := query.Render(dynamodb.New())

// Firestore
result, _ := query.Render(firestore.New())

// CouchDB (Mango queries)
result, _ := query.Render(couchdb.New())
```

Each provider handles dialect-specific syntax and unsupported feature rejection. MongoDB supports full aggregation pipelines. DynamoDB uses expression syntax. Firestore has inequality limitations. CouchDB produces Mango queries.

## Companion Libraries

DOCQL is part of a suite of schema-validated query builders:

| Library | Purpose | Schema |
|---------|---------|--------|
| [ASTQL](https://github.com/zoobzio/astql) | SQL databases | DBML |
| [VECTQL](https://github.com/zoobzio/vectql) | Vector databases | VDML |
| **DOCQL** | Document databases | DDML |

All three share the same architectural patterns: schema validation, internal types, parameterized output, and multi-provider support.
