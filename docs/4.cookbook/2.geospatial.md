---
title: Geospatial Queries
description: Location-based query patterns
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Cookbook
  - Geospatial
  - Location
---

# Geospatial Queries

This cookbook covers geospatial query patterns for location-based applications.

## Schema Setup

Define location fields in your DDML schema:

```go
schema := ddml.NewSchema("locations").
    AddCollection(
        ddml.NewCollection("stores").
            AddField(ddml.NewField("_id", ddml.TypeString)).
            AddField(ddml.NewField("name", ddml.TypeString)).
            AddField(ddml.NewField("location", ddml.TypeMap)). // GeoJSON point
            AddField(ddml.NewField("address.city", ddml.TypeString)).
            AddField(ddml.NewField("address.zip", ddml.TypeString)),
    )

instance, _ := docql.NewFromDDML(schema)
```

## Find Nearby

Find documents near a geographic point:

```go
func FindNearbyStores(instance *docql.DOCQL, maxDistance int) (*docql.QueryResult, error) {
    return docql.Find(instance.C("stores")).
        Filter(docql.Geo(
            instance.F("stores", "location"),
            instance.P("longitude"),
            instance.P("latitude"),
            instance.P("maxDistance"),
        )).
        Limit(20).
        Render(mongodb.New())
}

// Execute with:
// longitude: -73.97, latitude: 40.77, maxDistance: 5000 (meters)
```

## Distance-Sorted Results

Return results sorted by distance:

```go
func FindNearestStores(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("stores")).
        Filter(docql.GeoNear(
            instance.F("stores", "location"),
            instance.P("longitude"),
            instance.P("latitude"),
            instance.P("maxDistance"),
        )).
        Limit(10).
        Render(mongodb.New())
}
// MongoDB uses $near which returns results sorted by distance
```

## Within Radius

Find all locations within a specific radius:

```go
func FindWithinRadius(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("stores")).
        Filter(docql.GeoWithinSphere(
            instance.F("stores", "location"),
            instance.P("centerLon"),
            instance.P("centerLat"),
            instance.P("radiusKm"),
        )).
        Render(mongodb.New())
}
```

## Within Polygon

Find locations within a geographic boundary:

```go
func FindWithinArea(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("deliveryZones")).
        Filter(docql.GeoWithinPolygon(
            instance.F("deliveryZones", "serviceArea"),
            instance.P("polygon"), // Array of [lon, lat] coordinates
        )).
        Render(mongodb.New())
}
```

## Bounding Box Query

Find locations within a rectangular area:

```go
func FindInBoundingBox(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("stores")).
        Filter(docql.GeoWithinBox(
            instance.F("stores", "location"),
            instance.P("swLon"), // Southwest corner longitude
            instance.P("swLat"), // Southwest corner latitude
            instance.P("neLon"), // Northeast corner longitude
            instance.P("neLat"), // Northeast corner latitude
        )).
        Render(mongodb.New())
}
```

## Combined Filters

Combine geospatial with other filters:

```go
func FindNearbyOpenStores(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("stores")).
        Filter(instance.And(
            docql.Geo(
                instance.F("stores", "location"),
                instance.P("longitude"),
                instance.P("latitude"),
                instance.P("maxDistance"),
            ),
            instance.Eq(instance.F("stores", "isOpen"), instance.P("isOpen")),
            instance.In(instance.F("stores", "category"), instance.P("categories")),
        )).
        Limit(20).
        Render(mongodb.New())
}
```

## Aggregation with Geo

Calculate distances in aggregation:

```go
func GetStoresWithDistance(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Aggregate(instance.C("stores")).
        GeoNear(
            instance.F("stores", "location"),
            instance.P("longitude"),
            instance.P("latitude"),
            "distance", // Output field name for distance
            instance.P("maxDistance"),
        ).
        Match(instance.Eq(instance.F("stores", "isOpen"), instance.P("isOpen"))).
        Limit(20).
        Render(mongodb.New())
}
// Returns documents with a "distance" field containing meters from query point
```

## Store Locator Pattern

Complete store locator implementation:

```go
type StoreLocator struct {
    instance *docql.DOCQL
}

func (s *StoreLocator) FindStores(
    lat, lon float64,
    radiusKm float64,
    categories []string,
    limit int,
) (*docql.QueryResult, error) {
    maxDistanceMeters := radiusKm * 1000

    query := docql.Find(s.instance.C("stores")).
        Filter(docql.Geo(
            s.instance.F("stores", "location"),
            s.instance.P("longitude"),
            s.instance.P("latitude"),
            s.instance.P("maxDistance"),
        ))

    if len(categories) > 0 {
        query = query.Filter(
            s.instance.In(s.instance.F("stores", "category"), s.instance.P("categories")),
        )
    }

    return query.
        Select(
            s.instance.F("stores", "name"),
            s.instance.F("stores", "address"),
            s.instance.F("stores", "location"),
            s.instance.F("stores", "hours"),
        ).
        Limit(limit).
        Render(mongodb.New())
}
```

## Provider Support

| Feature | MongoDB | DynamoDB | Firestore | CouchDB |
|---------|---------|----------|-----------|---------|
| Near | Yes | No | Yes | Yes |
| Within radius | Yes | No | Yes | Yes |
| Within polygon | Yes | No | No | Yes |
| Bounding box | Yes | No | Yes | Yes |
| Distance sort | Yes | No | Yes | Limited |
| GeoJSON | Yes | No | Yes | Yes |

### DynamoDB Alternative

DynamoDB requires geohashing for location queries:

```go
// Use a geohash library to compute hash prefixes
// Query by hash key with range conditions
```

### Firestore Approach

Firestore uses Geopoints with geohash-based queries:

```go
// Firestore renderer handles conversion to geohash range queries
```

## Index Requirements

Ensure geospatial indexes exist:

```javascript
// MongoDB
db.stores.createIndex({ location: "2dsphere" })

// CouchDB - create a Mango index
{
  "index": {
    "fields": ["location"]
  },
  "type": "json"
}
```

## Best Practices

1. **Use 2dsphere indexes** - Required for geospatial queries in MongoDB
2. **Limit results** - Always set reasonable limits for geo queries
3. **Combine with filters** - Reduce result set before distance calculations
4. **Cache common queries** - Store locator results for popular locations
5. **Validate coordinates** - Ensure lon/lat are in valid ranges
