---
title: Text Search
description: Full-text search patterns
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Cookbook
  - Text Search
  - Full-text
---

# Text Search

This cookbook covers full-text search patterns for document databases.

## Basic Text Search

Simple text search on indexed fields:

```go
func SearchProducts(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("products")).
        Filter(docql.TextSearch(instance.P("searchTerm"))).
        Render(mongodb.New())
}

// Execute with: searchTerm = "wireless headphones"
```

## Text Search with Score

Return results ranked by relevance:

```go
func SearchWithScore(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("products")).
        Filter(docql.TextSearch(instance.P("searchTerm"))).
        Select(
            instance.F("products", "name"),
            instance.F("products", "description"),
        ).
        SelectMeta("score", "textScore"). // Include relevance score
        SortByMeta("textScore", docql.Descending).
        Limit(20).
        Render(mongodb.New())
}
```

## Phrase Search

Search for exact phrases:

```go
func SearchPhrase(instance *docql.DOCQL) (*docql.QueryResult, error) {
    // Wrap phrase in quotes in the parameter value
    // searchTerm = "\"noise cancelling\""
    return docql.Find(instance.C("products")).
        Filter(docql.TextSearch(instance.P("searchTerm"))).
        Render(mongodb.New())
}
```

## Exclude Terms

Search with negation:

```go
func SearchWithExclusions(instance *docql.DOCQL) (*docql.QueryResult, error) {
    // searchTerm = "headphones -wired"
    return docql.Find(instance.C("products")).
        Filter(docql.TextSearch(instance.P("searchTerm"))).
        Render(mongodb.New())
}
```

## Combined Search and Filter

Text search with additional conditions:

```go
func SearchInCategory(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("products")).
        Filter(instance.And(
            docql.TextSearch(instance.P("searchTerm")),
            instance.Eq(instance.F("products", "category"), instance.P("category")),
            instance.Gte(instance.F("products", "rating"), instance.P("minRating")),
            instance.Eq(instance.F("products", "inStock"), instance.P("inStock")),
        )).
        Limit(50).
        Render(mongodb.New())
}
```

## Regex Search

Pattern-based search for providers without full-text:

```go
func RegexSearch(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("products")).
        Filter(docql.Regex(
            instance.F("products", "name"),
            instance.P("pattern"),
        )).
        Limit(20).
        Render(mongodb.New())
}

// Execute with: pattern = "^wire.*head"
```

## Case-Insensitive Regex

```go
func CaseInsensitiveSearch(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("products")).
        Filter(docql.RegexWithOptions(
            instance.F("products", "name"),
            instance.P("pattern"),
            instance.P("options"), // "i" for case-insensitive
        )).
        Render(mongodb.New())
}
```

## Autocomplete Pattern

Prefix-based search for autocomplete:

```go
func Autocomplete(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Find(instance.C("products")).
        Filter(docql.RegexWithOptions(
            instance.F("products", "name"),
            instance.P("prefix"), // "^" + userInput
            instance.P("options"), // "i"
        )).
        Select(
            instance.F("products", "_id"),
            instance.F("products", "name"),
        ).
        Limit(10).
        Render(mongodb.New())
}
```

## Search Aggregation

Text search in aggregation pipeline:

```go
func SearchAndAggregate(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Aggregate(instance.C("products")).
        Match(docql.TextSearch(instance.P("searchTerm"))).
        Group(
            docql.FieldExpr(instance.F("products", "category")),
            map[string]docql.Accumulator{
                "count":    docql.CountAcc(),
                "avgPrice": docql.Avg(docql.FieldExpr(instance.F("products", "price"))),
            },
        ).
        Sort(instance.F("products", "count"), docql.Descending).
        Render(mongodb.New())
}
```

## Faceted Search

Search with category facets:

```go
func FacetedSearch(instance *docql.DOCQL) (*docql.QueryResult, error) {
    return docql.Aggregate(instance.C("products")).
        Match(docql.TextSearch(instance.P("searchTerm"))).
        Facet(map[string][]docql.PipelineStage{
            "results": {
                docql.SortStage(instance.F("products", "relevance"), docql.Descending),
                docql.LimitStage(20),
            },
            "categories": {
                docql.GroupStage(
                    docql.FieldExpr(instance.F("products", "category")),
                    map[string]docql.Accumulator{"count": docql.CountAcc()},
                ),
            },
            "priceRanges": {
                docql.BucketStage(
                    docql.FieldExpr(instance.F("products", "price")),
                    []int{0, 25, 50, 100, 200},
                ),
            },
        }).
        Render(mongodb.New())
}
```

## Search Service Pattern

Reusable search service:

```go
type SearchService struct {
    instance *docql.DOCQL
    renderer docql.Renderer
}

type SearchOptions struct {
    Query      string
    Categories []string
    MinPrice   *float64
    MaxPrice   *float64
    InStock    *bool
    SortBy     string
    Page       int
    PageSize   int
}

func (s *SearchService) Search(opts SearchOptions) (*docql.QueryResult, error) {
    var filters []docql.FilterItem

    // Text search
    if opts.Query != "" {
        filters = append(filters, docql.TextSearch(s.instance.P("query")))
    }

    // Category filter
    if len(opts.Categories) > 0 {
        filters = append(filters,
            s.instance.In(s.instance.F("products", "category"), s.instance.P("categories")))
    }

    // Price range
    if opts.MinPrice != nil || opts.MaxPrice != nil {
        var min, max *docql.Param
        if opts.MinPrice != nil {
            p := s.instance.P("minPrice")
            min = &p
        }
        if opts.MaxPrice != nil {
            p := s.instance.P("maxPrice")
            max = &p
        }
        filters = append(filters, docql.Range(s.instance.F("products", "price"), min, max))
    }

    // Stock filter
    if opts.InStock != nil {
        filters = append(filters,
            s.instance.Eq(s.instance.F("products", "inStock"), s.instance.P("inStock")))
    }

    query := docql.Find(s.instance.C("products"))

    if len(filters) > 0 {
        query = query.Filter(s.instance.And(filters...))
    }

    // Sorting
    switch opts.SortBy {
    case "price_asc":
        query = query.SortAsc(s.instance.F("products", "price"))
    case "price_desc":
        query = query.SortDesc(s.instance.F("products", "price"))
    case "rating":
        query = query.SortDesc(s.instance.F("products", "rating"))
    default:
        // Default to relevance (text score)
        query = query.SortByMeta("textScore", docql.Descending)
    }

    // Pagination
    offset := (opts.Page - 1) * opts.PageSize
    query = query.Skip(offset).Limit(opts.PageSize)

    return query.Render(s.renderer)
}
```

## Provider Support

| Feature | MongoDB | DynamoDB | Firestore | CouchDB |
|---------|---------|----------|-----------|---------|
| Full-text search | Yes | No | No | Yes |
| Text score | Yes | No | No | No |
| Regex | Yes | Limited | No | Yes |
| Case insensitive | Yes | Limited | No | Yes |
| Phrase search | Yes | No | No | Yes |
| Stemming | Yes | No | No | No |

### Alternatives for Unsupported Providers

For providers without full-text search:

1. **External search service** - Use Elasticsearch, Algolia, or Typesense
2. **Application-level search** - Fetch and filter in application
3. **Regex patterns** - Use regex for simple pattern matching
4. **Computed fields** - Pre-compute search tokens

## Index Requirements

Create text indexes for search:

```javascript
// MongoDB - single field
db.products.createIndex({ name: "text" })

// MongoDB - multiple fields with weights
db.products.createIndex(
  { name: "text", description: "text", tags: "text" },
  { weights: { name: 10, description: 5, tags: 1 } }
)

// CouchDB - create search index
{
  "_id": "_design/search",
  "indexes": {
    "products": {
      "analyzer": "standard",
      "index": "function(doc) { index('default', doc.name + ' ' + doc.description); }"
    }
  }
}
```

## Best Practices

1. **Index relevant fields** - Only index fields that need searching
2. **Use field weights** - Weight title/name higher than description
3. **Limit results** - Text search can be expensive; always limit
4. **Combine with filters** - Reduce result set before text scoring
5. **Consider external search** - For complex search needs, use dedicated search engines
