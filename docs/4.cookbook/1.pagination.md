---
title: Pagination Patterns
description: Implementing efficient pagination
author: zoobzio
published: 2025-12-29
updated: 2025-12-29
tags:
  - Cookbook
  - Pagination
  - Performance
---

# Pagination Patterns

This cookbook covers common pagination strategies for document databases.

## Offset-Based Pagination

The simplest approach using Skip and Limit:

```go
func GetPage(instance *docql.DOCQL, page, pageSize int) (*docql.QueryResult, error) {
    offset := (page - 1) * pageSize

    return docql.Find(instance.C("users")).
        SortAsc(instance.F("users", "createdAt")).
        Skip(offset).
        Limit(pageSize).
        Render(mongodb.New())
}
```

### Limitations

- Performance degrades with large offsets (database must scan skipped documents)
- Inconsistent results if data changes between page requests
- Not suitable for datasets over ~10,000 documents

## Cursor-Based Pagination

More efficient for large datasets:

```go
func GetNextPage(instance *docql.DOCQL, cursor string, limit int) (*docql.QueryResult, error) {
    query := docql.Find(instance.C("users")).
        SortAsc(instance.F("users", "_id")).
        Limit(limit)

    if cursor != "" {
        query = query.Filter(
            instance.Gt(instance.F("users", "_id"), instance.P("cursor")),
        )
    }

    return query.Render(mongodb.New())
}
```

### Usage Pattern

```go
// First page
result1 := GetNextPage(instance, "", 20)
// Execute with no cursor parameter

// Next page - use last document's _id as cursor
result2 := GetNextPage(instance, lastDocId, 20)
// Execute with cursor = "last_id_from_previous_page"
```

## Keyset Pagination

For sorting by non-unique fields:

```go
func GetPageByCreatedAt(instance *docql.DOCQL, lastCreatedAt, lastId string, limit int) (*docql.QueryResult, error) {
    query := docql.Find(instance.C("posts")).
        SortDesc(instance.F("posts", "createdAt")).
        SortAsc(instance.F("posts", "_id")).
        Limit(limit)

    if lastCreatedAt != "" {
        // Documents with earlier createdAt OR same createdAt but later _id
        query = query.Filter(
            instance.Or(
                instance.Lt(instance.F("posts", "createdAt"), instance.P("lastCreatedAt")),
                instance.And(
                    instance.Eq(instance.F("posts", "createdAt"), instance.P("lastCreatedAt")),
                    instance.Gt(instance.F("posts", "_id"), instance.P("lastId")),
                ),
            ),
        )
    }

    return query.Render(mongodb.New())
}
```

## Paginated Response

Structure for API responses:

```go
type PaginatedResponse struct {
    Data       []map[string]interface{} `json:"data"`
    Pagination PaginationMeta           `json:"pagination"`
}

type PaginationMeta struct {
    Page       int    `json:"page,omitempty"`       // Offset pagination
    PageSize   int    `json:"pageSize"`
    TotalCount int    `json:"totalCount,omitempty"` // Expensive for large datasets
    HasMore    bool   `json:"hasMore"`
    NextCursor string `json:"nextCursor,omitempty"` // Cursor pagination
}
```

## Getting Total Count

```go
func GetPageWithCount(instance *docql.DOCQL, filter docql.FilterItem, page, pageSize int) (dataQuery, countQuery *docql.QueryResult, err error) {
    offset := (page - 1) * pageSize

    // Data query
    dataQuery, err = docql.Find(instance.C("users")).
        Filter(filter).
        SortAsc(instance.F("users", "createdAt")).
        Skip(offset).
        Limit(pageSize).
        Render(mongodb.New())
    if err != nil {
        return nil, nil, err
    }

    // Count query (same filter, no pagination)
    countQuery, err = docql.Count(instance.C("users")).
        Filter(filter).
        Render(mongodb.New())
    if err != nil {
        return nil, nil, err
    }

    return dataQuery, countQuery, nil
}
```

## Infinite Scroll Pattern

For mobile/web infinite scroll:

```go
type InfiniteScrollQuery struct {
    instance  *docql.DOCQL
    pageSize  int
    sortField string
}

func (q *InfiniteScrollQuery) GetItems(afterId string) (*docql.QueryResult, error) {
    query := docql.Find(q.instance.C("feed")).
        SortDesc(q.instance.F("feed", q.sortField)).
        Limit(q.pageSize + 1) // Fetch one extra to check hasMore

    if afterId != "" {
        query = query.Filter(
            q.instance.Lt(q.instance.F("feed", "_id"), q.instance.P("afterId")),
        )
    }

    return query.Render(mongodb.New())
}
```

## Bidirectional Pagination

Navigate forward and backward:

```go
func GetPageBidirectional(
    instance *docql.DOCQL,
    cursor string,
    direction string, // "next" or "prev"
    limit int,
) (*docql.QueryResult, error) {
    query := docql.Find(instance.C("items"))

    if direction == "next" {
        query = query.
            Filter(instance.Gt(instance.F("items", "_id"), instance.P("cursor"))).
            SortAsc(instance.F("items", "_id"))
    } else {
        query = query.
            Filter(instance.Lt(instance.F("items", "_id"), instance.P("cursor"))).
            SortDesc(instance.F("items", "_id"))
    }

    return query.Limit(limit).Render(mongodb.New())
}
```

## Aggregation Pagination

Paginate aggregation results:

```go
func GetGroupedPage(instance *docql.DOCQL, skip, limit int) (*docql.QueryResult, error) {
    return docql.Aggregate(instance.C("orders")).
        Match(instance.Eq(instance.F("orders", "status"), instance.P("status"))).
        Group(
            docql.FieldExpr(instance.F("orders", "customerId")),
            map[string]docql.Accumulator{
                "totalAmount": docql.Sum(docql.FieldExpr(instance.F("orders", "amount"))),
                "orderCount":  docql.CountAcc(),
            },
        ).
        Sort(instance.F("orders", "totalAmount"), docql.Descending).
        Skip(skip).
        Limit(limit).
        Render(mongodb.New())
}
```

## Provider Considerations

| Provider | Skip/Limit | Cursor | Notes |
|----------|------------|--------|-------|
| MongoDB | Yes | Yes | Full support |
| DynamoDB | Limited | Yes | Use LastEvaluatedKey |
| Firestore | Yes | Yes | startAfter/startAt cursors |
| CouchDB | Yes | Yes | bookmark parameter |

## Best Practices

1. **Default page sizes** - Set reasonable defaults (20-50 items)
2. **Maximum limits** - Enforce maximum page sizes (100-500)
3. **Consistent sorting** - Always include a unique field in sort for deterministic results
4. **Index support** - Ensure pagination fields are indexed
5. **Avoid deep pagination** - Use cursor-based for large datasets
